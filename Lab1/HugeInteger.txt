
/*
 * For Lab 1, demonstrate the following:
 * (1) The constructors of 'HugeInteger' class
 * (2) The addition operation for positive integers
 */

import java.util.*;

public class HugeInteger {
	
	private String remainder;
	private int[] multiples = new int[10];
	private int sign = 0;
	
	public HugeInteger(String num)
	{
		initializeHugeInteger(num);
	}
	
	public HugeInteger(int n) throws IllegalArgumentException
	{
		if(n <= 1)
		{
			//This is the one requirement for this constructor - (n) must be larger than 1
			throw new IllegalArgumentException("Argument must be LARGER than 1");
		}
		else
		{
			//Creates a random number with (n) digits - first digit can't be 0
			String improvisedString = Integer.toString( (int) (Math.random() * ((9 - 1) + 1) + 1) );
			
			for(int i = 0; i < n; i++)
			{
				improvisedString = improvisedString + Integer.toString( (int) (Math.random() * (9)) );;
			}
			System.out.println("generated string = " + improvisedString);
			
			//Use the same method as before to initialize the (HugeInteger)
			initializeHugeInteger(improvisedString);
		}
	}
	
	public void initializeHugeInteger(String num)
	{
		//Off the bat, this.remainder is set to the number passed into the constructor
		this.remainder = num;
		
		//Initializing Sign
		if(num.charAt(0) == '-')
		{
			this.sign = -1;
			//Get rid of the sign for setting up the rest of the number
			this.remainder = this.remainder.substring(1);
		}
		else {sign = 1;}
		
		do
		{
			if(isSmallerOrEqualThanSecondParameter(this.remainder, Integer.toString(Integer.MAX_VALUE)))
			{
				//Do nothing
			}
			else
			{
				//Get to the earliest available element
				for(int index = 0; index < multiples.length - 1; index++)
				{
					if(this.multiples[index] <= Integer.MAX_VALUE && this.multiples[index + 1] == 0)
					{
						this.multiples[index]++;
						break;
					}
				}
				
				this.remainder = subtractStrings(this.remainder, Integer.toString(Integer.MAX_VALUE));	
			}
		}while(!isSmallerOrEqualThanSecondParameter(this.remainder, Integer.toString(Integer.MAX_VALUE)));
	}

	public static Boolean isSmallerOrEqualThanSecondParameter(String num, String max_int)
	{		
		//trimming off any noise in (num)
		num = num.trim();
		if(max_int.length() > num.length())
		{
			return true;
		}
		else if(max_int.length() < num.length())
		{
			return false;
		}else
		{
			//If the sizes are equal, check one by one
			int num_current;
			int max_current;
			for(int i = 0; i < max_int.length(); i++)
			{
				num_current = Integer.parseInt(String.valueOf(num.charAt(i)));
				max_current = Integer.parseInt(String.valueOf(max_int.charAt(i)));
				if(max_current == num_current)
				{
					//Do nothing
				}
				else if(max_current < num_current)
				{
					return false;
				}
				else
				{
					return true;
				}
			}
			
			//If program gets here, (num) == Integer.MAX_VALUE
			return false;
		}
	}
	
	public static String subtractStrings(String longer, String shorter) throws IllegalArgumentException
	{
		String remaining = "";
		String backwardsString = "";
		String finalString = "";
		int carryOffset = 0;
		int offset = longer.length() - shorter.length();
		
		if(offset < 0)
		{
			throw new IllegalArgumentException("Wrong Order Of Parameters");
		}
		
		for(int i = longer.length() - 1; i >= offset; i--)
		{
			if(Character.getNumericValue(longer.charAt(i)) < Character.getNumericValue(shorter.charAt(i - offset)))
			{
				//This is the "carry" case
				remaining = "";
				carryOffset = 0;
				
				//Adding 10, then subtracting from the bottom - then adding it to the final string
				remaining = remaining + Integer.toString(Character.getNumericValue(longer.charAt(i)) + 10 - Character.getNumericValue(shorter.charAt(i - offset)));
				backwardsString += remaining;
				
				//Then remove 1 from the column I just borrowed from
				if(Integer.toString(Character.getNumericValue(longer.charAt(i - carryOffset - 1))).equals("0"))
				{
					longer = longer.substring(0, i - carryOffset - 2) + Integer.toString(Character.getNumericValue(longer.charAt(i - carryOffset - 2)) - 1) + "9" + longer.substring(i - carryOffset);
				}
				else
				{
					longer = longer.substring(0, i - carryOffset - 1) + Integer.toString(Character.getNumericValue(longer.charAt(i - carryOffset - 1)) - 1) + longer.substring(i - carryOffset);
				}
				
			}else
			{
				//Here occurs normal subtraction
				remaining = "";
				
				remaining = remaining + Integer.toString(Character.getNumericValue(longer.charAt(i)) - Character.getNumericValue(shorter.charAt(i - offset)));
				backwardsString += remaining;
			}
		}
		
		//Add any decimal places that weren't touched
		for(int i = offset - 1; i >= 0; i--)
		{
			backwardsString = backwardsString + longer.charAt(i);
		}
		
		//NOW have to flip the string (the logic above puts it in 'finalString' backwards)
		for(int i = backwardsString.length() - 1; i >= 0; i--)
		{
			finalString = finalString + backwardsString.charAt(i);
		}
		
		//Remove any 0's at the beginning of 'finalString'
		int finalLength = finalString.length();
		for(int i = 0; i < finalLength - 1; i++)
		{
			if(finalString.charAt(0) == '0')
			{
				finalString = finalString.substring(1);
			}
		}
		return finalString;
	}

	public String addStrings(String longer, String shorter) throws IllegalArgumentException
	{
		String remaining = "";
		String backwardsString = "";
		String finalString = "";
		int carryOffset = 0;
		int offset = longer.length() - shorter.length();
		
		if(offset < 0)
		{
			throw new IllegalArgumentException("Wrong Order Of Parameters");
		}
		
		for(int i = longer.length() - 1; i >= offset; i--)
		{
			if(Character.getNumericValue(longer.charAt(i)) + Character.getNumericValue(shorter.charAt(i - offset)) >= 10)
			{
				//The carry condition
				remaining = "";
				carryOffset = 0;
				
				remaining = remaining + Integer.toString(Character.getNumericValue(longer.charAt(i)) + Character.getNumericValue(shorter.charAt(i - offset)) - 10);
				backwardsString += remaining;
				
				//Adding 1 to the next column
				//The next line makes sure the carry works properly
				while(Integer.toString(Character.getNumericValue(longer.charAt(i - carryOffset - 1))).equals("9"))
				{
					longer = longer.substring(0, i - 1) + "0" + longer.substring(i);
					carryOffset++;
				}
				longer = longer.substring(0, i - carryOffset - 1) + Integer.toString(Character.getNumericValue(longer.charAt(i - carryOffset - 1)) + 1) + longer.substring(i - carryOffset);
				
			}else
			{
				remaining = "";
				
				remaining = remaining + Integer.toString(Character.getNumericValue(longer.charAt(i)) + Character.getNumericValue(shorter.charAt(i - offset)));
				backwardsString += remaining;
			}
		}
		
		//Add any decimal places that weren't touched
		for(int i = offset - 1; i >= 0; i--)
		{
			backwardsString = backwardsString + longer.charAt(i);
		}
		
		//NOW have to flip the string (the logic above puts it in 'finalString' backwards)
		for(int i = backwardsString.length() - 1; i >= 0; i--)
		{
			finalString = finalString + backwardsString.charAt(i);
		}
		
		//Remove any 0's at the beginning of 'finalString'
		int finalLength = finalString.length();
		for(int i = 0; i < finalLength - 1; i++)
		{
			if(finalString.charAt(0) == '0')
			{
				finalString = finalString.substring(1);
			}
		}
		return finalString;
	}

 	public String toString()
	{
		String totalString = "";
		totalString += "Remainder = " + this.remainder + "\n" + "MAX_INT Multiple Array = [ ";
		
		for(int i = 0; i < this.multiples.length; i++)
		{
			totalString += this.multiples[i] + " ";
		}
		
		totalString += "]\n" + "Sign = " + this.sign;
		
		return totalString;
	}
	
	public HugeInteger add(HugeInteger h)
	{
		String stringOfNumbers = "0";
		String thisString = "0";
		String hString = "0";
		String max_int = Integer.toString(Integer.MAX_VALUE);
		
		//Getting string of 'this' number
		for(int i = 0; i < this.multiples.length - 1; i++)
		{
			while(this.multiples[i] > 0)
			{
				if(isSmallerOrEqualThanSecondParameter(thisString, Integer.toString(Integer.MAX_VALUE)))
				{
					thisString = addStrings(max_int, thisString);
				}
				else
				{
					thisString = addStrings(thisString, max_int);
				}
				this.multiples[i] --;
			}
			if(this.multiples[i] == 0 && this.multiples[i + 1] == 0)
			{
				break;
			}
		}
		if(isSmallerOrEqualThanSecondParameter(this.remainder, thisString))
		{
			thisString = addStrings(thisString, this.remainder);
		}
		else
		{
			thisString = addStrings(this.remainder, thisString);
		}
		
		//Getting string of 'h' number
		for(int i = 0; i < h.multiples.length - 1; i++)
		{
			while(h.multiples[i] > 0)
			{
				if(h.multiples[i] > 0)
				{
					if(isSmallerOrEqualThanSecondParameter(hString, Integer.toString(Integer.MAX_VALUE)))
					{
						hString = addStrings(max_int, hString);
					}
					else
					{
						hString = addStrings(hString, max_int);
					}
					h.multiples[i] --;
				}
			}
			if(h.multiples[i] == 0 && h.multiples[i + 1] == 0)
			{
				break;
			}
		}
		if(isSmallerOrEqualThanSecondParameter(hString, h.remainder))
		{
			hString = addStrings(h.remainder, hString);
		}
		else
		{
			hString = addStrings(hString, h.remainder);
		}
		
		//Adding both 'this' and 'h' strings
		if(isSmallerOrEqualThanSecondParameter(thisString, hString))
		{
			stringOfNumbers = addStrings(hString, thisString);
		}
		else
		{
			stringOfNumbers = addStrings(thisString, hString);
		}
		
		//Making the HugeInteger objects to be returned
		HugeInteger finalObject = new HugeInteger(stringOfNumbers);
		return finalObject;
	}

	public static void main(String[] args)
	{
		//MAX = 2147483647
		//Ex = 4294967294	
		
		HugeInteger h1 = new HugeInteger("12301");
		HugeInteger h2 = new HugeInteger("198");
		
		System.out.println(subtractStrings("12301", "198"));
	}

}